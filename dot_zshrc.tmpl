# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH

export TERM="xterm-256color"
export EDITOR="vim" 

# Path to your Oh My Zsh installation.
# export ZSH="$HOME/.oh-my-zsh"
autoload -Uz compinit && compinit
autoload -Uz promptinit && promptinit

export PATH="$HOME/.cargo/bin:$PATH"
eval "$(sheldon source)"

MNML_PROMPT=(mnml_ssh mnml_pyenv mnml_status)

alias cat="bat"
alias ls="eza --icons"
alias tree="eza --icons --tree" 
alias l="ls -lah"
alias c="gcc -Wall -Wextra -Werror"

# Fonction: reach anywhere
f() {
	cat=$(fd . "$HOME" -t d | fzf) 
	cd $cat
}

HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000

setopt SHARE_HISTORY
setopt APPEND_HISTORY
setopt INC_APPEND_HISTORY

# ===================
# CONFIGURATION LINUX
# ===================
{{ if eq .chezmoi.os "linux" -}}

# Window title
precmd() { print -Pn -- '\e]2;$(whoami)@$(hostname): %~\a' }
preexec() { print -Pn -- '\e]2;$1\a' }

# Key bindings
bindkey "\e[1;5D" backward-word
bindkey "\e[1;5C" forward-word

bindkey "\e[H" beginning-of-line
bindkey "\e[F" end-of-line

{{ end -}}

# ===================
# CONFIGURATION MACOS
# ===================
{{ if eq .chezmoi.os "darwin" -}}

# Sudo prompt
export SUDO_PROMPT="üîê " 

export BW_SESSION="OQ7V+V4NGaUU7e4dntUo/S/w4geTvK/wLNxWuM8PerdXdUYgtlh+Rn6b8HL6w2IESVnBb+KGXZOnyqOG+ObtEQ=="
export PATH="$JAVA_HOME/bin:$PATH"
export PATH="/opt/homebrew/opt/postgresql@17/bin:$PATH"
export PATH="/opt/homebrew/opt/postgresql@17/bin:$PATH"
export PATH="$HOME/.bin:$PATH"
export PATH="/opt/Grapp/bin:$PATH"
export PATH="/Library/Maven/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"

JAVA_LIB_DIR="$HOME/.java"

if [ -d "$JAVA_LIB_DIR" ]; then

    # 1. On utilise le "globbing" (pattern matching) de Zsh pour trouver les JARs
    # **/*.jar(N) : cherche r√©cursivement '**' tous les fichiers '.jar'
    # (N) : L'option 'nullglob' fait qu'il ne renvoie rien si aucun fichier n'est trouv√©,
    #       au lieu de laisser le pattern tel quel.

    # On stocke les chemins dans un tableau Zsh, en d√©sactivant le partage d'IFS
    # pour √©viter les warnings.
    local jars_array
    jars_array=( "$JAVA_LIB_DIR"/**/*.jar(N) )

    # 2. On v√©rifie si on a trouv√© des JARs avant de toucher √† CLASSPATH
    if [ ${#jars_array[@]} -gt 0 ]; then
        # On d√©finit le s√©parateur (la variable IFS) uniquement pour cette commande de "join"
        # et on le fait de mani√®re plus directe.
        local IFS_OLD="$IFS" # On sauvegarde l'IFS actuel
        IFS=':'              # On d√©finit l'IFS comme ":" pour le join
        
        # Le r√©sultat est CLASSPATH:jar1:jar2 (si CLASSPATH n'est pas vide)
        # Si CLASSPATH est vide, il sera juste :jar1:jar2, ce qui est g√©n√©ralement tol√©r√©
        # mais on peut faire mieux.

        # On cr√©e la nouvelle partie du CLASSPATH
        local new_classpath_part="${jars_array[*]}"
        
        # On restaure IFS imm√©diatement
        IFS="$IFS_OLD"
        
        # 3. On met √† jour CLASSPATH en s'assurant qu'on ajoute le s√©parateur seulement si n√©cessaire
        if [ -n "$CLASSPATH" ]; then
            # CLASSPATH non vide, on ajoute le s√©parateur (:)
            export CLASSPATH="$CLASSPATH:$new_classpath_part"
        else
            # CLASSPATH vide, on ajoute juste les chemins
            export CLASSPATH="$new_classpath_part"
        fi
    fi
fi

export CLASSPATH=".:$CLASSPATH"

{{ end -}}
